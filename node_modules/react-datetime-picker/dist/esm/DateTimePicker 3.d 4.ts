import React from 'react';
import PropTypes from 'prop-types';
import makeEventProps from 'make-event-props';
import Calendar from 'react-calendar';
import Clock from 'react-clock';
import { isMaxDate, isMinDate } from './shared/propTypes';
import type { ClassName, CloseReason, Detail, LooseValue, OpenReason, Value } from './shared/types';
type Icon = React.ReactElement | string;
type IconOrRenderFunction = Icon | React.ComponentType | React.ReactElement;
type CalendarProps = Omit<React.ComponentPropsWithoutRef<typeof Calendar>, 'className' | 'maxDetail' | 'onChange'>;
type ClockProps = Omit<React.ComponentPropsWithoutRef<typeof Clock>, 'value'>;
type EventProps = ReturnType<typeof makeEventProps>;
export type DateTimePickerProps = {
    amPmAriaLabel?: string;
    autoFocus?: boolean;
    calendarAriaLabel?: string;
    calendarClassName?: ClassName;
    calendarIcon?: IconOrRenderFunction | null;
    className?: ClassName;
    clearAriaLabel?: string;
    clearIcon?: IconOrRenderFunction | null;
    clockClassName?: ClassName;
    closeWidgets?: boolean;
    'data-testid'?: string;
    dayAriaLabel?: string;
    dayPlaceholder?: string;
    disableCalendar?: boolean;
    disableClock?: boolean;
    disabled?: boolean;
    format?: string;
    hourAriaLabel?: string;
    hourPlaceholder?: string;
    id?: string;
    isCalendarOpen?: boolean;
    isClockOpen?: boolean;
    locale?: string;
    maxDate?: Date;
    maxDetail?: Detail;
    minDate?: Date;
    minuteAriaLabel?: string;
    minutePlaceholder?: string;
    monthAriaLabel?: string;
    monthPlaceholder?: string;
    name?: string;
    nativeInputAriaLabel?: string;
    onCalendarClose?: () => void;
    onCalendarOpen?: () => void;
    onChange?: (value: Value) => void;
    onClockClose?: () => void;
    onClockOpen?: () => void;
    onFocus?: (event: React.FocusEvent<HTMLDivElement>) => void;
    onInvalidChange?: () => void;
    openWidgetsOnFocus?: boolean;
    portalContainer?: HTMLElement | null;
    required?: boolean;
    secondAriaLabel?: string;
    secondPlaceholder?: string;
    shouldCloseWidgets?: (props: {
        reason: CloseReason;
        widget: 'calendar' | 'clock';
    }) => boolean;
    shouldOpenWidgets?: (props: {
        reason: OpenReason;
        widget: 'calendar' | 'clock';
    }) => boolean;
    showLeadingZeros?: boolean;
    value?: LooseValue;
    yearAriaLabel?: string;
    yearPlaceholder?: string;
} & CalendarProps & ClockProps & Omit<EventProps, 'onChange' | 'onFocus'>;
declare function DateTimePicker(props: DateTimePickerProps): JSX.Element;
declare namespace DateTimePicker {
    var propTypes: {
        amPmAriaLabel: PropTypes.Requireable<string>;
        autoFocus: PropTypes.Requireable<boolean>;
        calendarAriaLabel: PropTypes.Requireable<string>;
        calendarClassName: PropTypes.Requireable<NonNullable<string | (string | null | undefined)[] | null | undefined>>;
        calendarIcon: PropTypes.Requireable<NonNullable<PropTypes.ReactNodeLike | ((...args: any[]) => any)>>;
        className: PropTypes.Requireable<NonNullable<string | (string | null | undefined)[] | null | undefined>>;
        clearAriaLabel: PropTypes.Requireable<string>;
        clearIcon: PropTypes.Requireable<NonNullable<PropTypes.ReactNodeLike | ((...args: any[]) => any)>>;
        clockClassName: PropTypes.Requireable<NonNullable<string | (string | null | undefined)[] | null | undefined>>;
        closeWidgets: PropTypes.Requireable<boolean>;
        'data-testid': PropTypes.Requireable<string>;
        dayAriaLabel: PropTypes.Requireable<string>;
        dayPlaceholder: PropTypes.Requireable<string>;
        disableCalendar: PropTypes.Requireable<boolean>;
        disableClock: PropTypes.Requireable<boolean>;
        disabled: PropTypes.Requireable<boolean>;
        format: PropTypes.Requireable<string>;
        hourAriaLabel: PropTypes.Requireable<string>;
        hourPlaceholder: PropTypes.Requireable<string>;
        id: PropTypes.Requireable<string>;
        isCalendarOpen: PropTypes.Requireable<boolean>;
        isClockOpen: PropTypes.Requireable<boolean>;
        locale: PropTypes.Requireable<string>;
        maxDate: typeof isMaxDate;
        maxDetail: PropTypes.Requireable<string>;
        minDate: typeof isMinDate;
        minuteAriaLabel: PropTypes.Requireable<string>;
        minutePlaceholder: PropTypes.Requireable<string>;
        monthAriaLabel: PropTypes.Requireable<string>;
        monthPlaceholder: PropTypes.Requireable<string>;
        name: PropTypes.Requireable<string>;
        nativeInputAriaLabel: PropTypes.Requireable<string>;
        onCalendarClose: PropTypes.Requireable<(...args: any[]) => any>;
        onCalendarOpen: PropTypes.Requireable<(...args: any[]) => any>;
        onChange: PropTypes.Requireable<(...args: any[]) => any>;
        onClockClose: PropTypes.Requireable<(...args: any[]) => any>;
        onClockOpen: PropTypes.Requireable<(...args: any[]) => any>;
        onFocus: PropTypes.Requireable<(...args: any[]) => any>;
        openWidgetsOnFocus: PropTypes.Requireable<boolean>;
        portalContainer: PropTypes.Requireable<object>;
        required: PropTypes.Requireable<boolean>;
        secondAriaLabel: PropTypes.Requireable<string>;
        secondPlaceholder: PropTypes.Requireable<string>;
        showLeadingZeros: PropTypes.Requireable<boolean>;
        value: PropTypes.Requireable<NonNullable<NonNullable<string | Date | null | undefined> | (NonNullable<string | Date | null | undefined> | null | undefined)[] | null | undefined>>;
        yearAriaLabel: PropTypes.Requireable<string>;
        yearPlaceholder: PropTypes.Requireable<string>;
    };
}
export default DateTimePicker;
